"""Config flow tests to improve coverage."""

import asyncio
import socket
from unittest.mock import MagicMock, patch

import pytest
from homeassistant.core import HomeAssistant

from custom_components.hass_dyson.config_flow import (
    DysonConfigFlow,
    _discover_device_via_mdns,
    _get_connection_type_display_name,
)
from custom_components.hass_dyson.const import DOMAIN


class TestDysonConfigFlowBasics:
    """Test basic config flow functionality."""

    def test_connection_type_display_names(self):
        """Test connection type display name mapping."""
        assert _get_connection_type_display_name("local_only") == "Local Only"
        assert _get_connection_type_display_name("cloud_only") == "Cloud Only"
        assert _get_connection_type_display_name("unknown_type") == "unknown_type"

    @pytest.mark.asyncio
    async def test_discover_device_via_mdns_no_zeroconf(self):
        """Test mDNS discovery when zeroconf is unavailable."""
        mock_hass = MagicMock()

        with patch("homeassistant.components.zeroconf.async_get_instance") as mock_async_get_instance:
            mock_async_get_instance.return_value = None

            result = await _discover_device_via_mdns(mock_hass, "TEST123")

            assert result is None

    @pytest.mark.asyncio
    async def test_discover_device_via_mdns_service_found(self):
        """Test mDNS discovery when service is found."""
        mock_hass = MagicMock()
        mock_zeroconf_instance = MagicMock()
        mock_service_info = MagicMock()
        mock_service_info.addresses = [socket.inet_aton("192.168.1.100")]

        mock_zeroconf_instance.get_service_info.return_value = mock_service_info

        with patch("homeassistant.components.zeroconf.async_get_instance") as mock_async_get_instance:
            mock_async_get_instance.return_value = mock_zeroconf_instance

            with patch("asyncio.wait_for") as mock_wait_for:
                with patch("asyncio.get_event_loop") as mock_loop:
                    mock_executor = MagicMock()
                    mock_loop.return_value.run_in_executor = mock_executor
                    mock_executor.return_value = "192.168.1.100"
                    mock_wait_for.return_value = "192.168.1.100"

                    result = await _discover_device_via_mdns(mock_hass, "TEST123")

                    assert result == "192.168.1.100"

    @pytest.mark.asyncio
    async def test_discover_device_via_mdns_hostname_fallback(self):
        """Test mDNS discovery hostname fallback."""
        mock_hass = MagicMock()
        mock_zeroconf_instance = MagicMock()
        mock_zeroconf_instance.get_service_info.return_value = None

        with patch("homeassistant.components.zeroconf.async_get_instance") as mock_async_get_instance:
            mock_async_get_instance.return_value = mock_zeroconf_instance

            with patch("socket.gethostbyname") as mock_gethostbyname:
                mock_gethostbyname.return_value = "192.168.1.200"

                with patch("asyncio.wait_for") as mock_wait_for:
                    with patch("asyncio.get_event_loop") as mock_loop:
                        mock_executor = MagicMock()
                        mock_loop.return_value.run_in_executor = mock_executor
                        mock_executor.return_value = "192.168.1.200"
                        mock_wait_for.return_value = "192.168.1.200"

                        result = await _discover_device_via_mdns(mock_hass, "TEST123")

                        assert result == "192.168.1.200"

    @pytest.mark.asyncio
    async def test_discover_device_via_mdns_timeout(self):
        """Test mDNS discovery timeout."""
        mock_hass = MagicMock()
        mock_zeroconf_instance = MagicMock()

        with patch("homeassistant.components.zeroconf.async_get_instance") as mock_async_get_instance:
            mock_async_get_instance.return_value = mock_zeroconf_instance

            with patch("asyncio.wait_for") as mock_wait_for:
                mock_wait_for.side_effect = asyncio.TimeoutError()

                result = await _discover_device_via_mdns(mock_hass, "TEST123")

                assert result is None

    @pytest.mark.asyncio
    async def test_discover_device_via_mdns_exception_handling(self):
        """Test mDNS discovery exception handling."""
        mock_hass = MagicMock()

        with patch("homeassistant.components.zeroconf.async_get_instance") as mock_async_get_instance:
            mock_async_get_instance.side_effect = Exception("Connection error")

            result = await _discover_device_via_mdns(mock_hass, "TEST123")

            assert result is None


class TestDysonConfigFlowFlow:
    """Test config flow class."""

    @pytest.fixture
    def mock_hass(self):
        """Mock Home Assistant."""
        hass = MagicMock(spec=HomeAssistant)
        hass.data = {}
        return hass

    @pytest.fixture
    def config_flow(self, mock_hass):
        """Create config flow instance."""
        flow = DysonConfigFlow()
        flow.hass = mock_hass
        return flow

    def test_config_flow_initialization(self, config_flow):
        """Test config flow is properly initialized."""
        assert config_flow.VERSION == 1
        assert config_flow.DOMAIN == DOMAIN

    @pytest.mark.asyncio
    async def test_async_step_user_initial(self, config_flow):
        """Test initial user step."""
        with patch.object(config_flow, "_async_check_existing_cloud_account") as mock_check:
            mock_check.return_value = None

            result = await config_flow.async_step_user()

            assert result["type"] == "form"
            assert result["step_id"] == "discovery_method"

    @pytest.mark.asyncio
    async def test_async_step_user_existing_cloud(self, config_flow):
        """Test user step with existing cloud account."""
        mock_entry = MagicMock()
        mock_entry.data = {"username": "test@example.com"}

        with patch.object(config_flow, "_async_check_existing_cloud_account") as mock_check:
            mock_check.return_value = mock_entry

            result = await config_flow.async_step_user()

            assert result["type"] == "form"
            assert result["step_id"] == "device_selection"

    def test_validate_ip_address_valid(self, config_flow):
        """Test IP address validation with valid address."""
        assert config_flow._validate_ip_address("192.168.1.100") is True
        assert config_flow._validate_ip_address("10.0.0.1") is True
        assert config_flow._validate_ip_address("172.16.0.1") is True

    def test_validate_ip_address_invalid(self, config_flow):
        """Test IP address validation with invalid address."""
        assert config_flow._validate_ip_address("not.an.ip") is False
        assert config_flow._validate_ip_address("256.256.256.256") is False
        assert config_flow._validate_ip_address("192.168.1") is False
        assert config_flow._validate_ip_address("") is False

    def test_validate_serial_number_valid(self, config_flow):
        """Test serial number validation with valid numbers."""
        assert config_flow._validate_serial_number("VS6-EU-HJA1234A") is True
        assert config_flow._validate_serial_number("358-EU-ABC1234A") is True
        assert config_flow._validate_serial_number("527-US-DEF5678B") is True

    def test_validate_serial_number_invalid(self, config_flow):
        """Test serial number validation with invalid numbers."""
        assert config_flow._validate_serial_number("") is False
        assert config_flow._validate_serial_number("invalid") is False
        assert config_flow._validate_serial_number("VS6") is False
        assert config_flow._validate_serial_number("123456789012345678901") is False  # Too long

    def test_validate_device_password_valid(self, config_flow):
        """Test device password validation with valid passwords."""
        assert config_flow._validate_device_password("abcDEF12345") is True
        assert config_flow._validate_device_password("XYZabc98765") is True

    def test_validate_device_password_invalid(self, config_flow):
        """Test device password validation with invalid passwords."""
        assert config_flow._validate_device_password("") is False
        assert config_flow._validate_device_password("short") is False
        assert config_flow._validate_device_password("toolongpasswordstring") is False
        assert config_flow._validate_device_password("no-special-chars") is False
        assert config_flow._validate_device_password("12345678901") is False  # No letters

    @pytest.mark.asyncio
    async def test_async_step_discovery_method_cloud(self, config_flow):
        """Test discovery method step with cloud selection."""
        user_input = {"discovery_method": "cloud"}

        result = await config_flow.async_step_discovery_method(user_input)

        assert result["type"] == "form"
        assert result["step_id"] == "cloud_login"

    @pytest.mark.asyncio
    async def test_async_step_discovery_method_manual(self, config_flow):
        """Test discovery method step with manual selection."""
        user_input = {"discovery_method": "manual"}

        result = await config_flow.async_step_discovery_method(user_input)

        assert result["type"] == "form"
        assert result["step_id"] == "manual_device"

    @pytest.mark.asyncio
    async def test_async_step_discovery_method_sticker(self, config_flow):
        """Test discovery method step with sticker selection."""
        user_input = {"discovery_method": "sticker"}

        result = await config_flow.async_step_discovery_method(user_input)

        assert result["type"] == "form"
        assert result["step_id"] == "sticker_device"
