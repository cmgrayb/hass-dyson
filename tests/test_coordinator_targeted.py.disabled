"""Targeted coordinator tests to improve coverage."""

from unittest.mock import AsyncMock, MagicMock, patch

import pytest
from homeassistant.helpers.update_coordinator import UpdateFailed

from custom_components.hass_dyson.const import CONF_DEVICE_NAME, CONF_SERIAL_NUMBER
from custom_components.hass_dyson.coordinator import DysonDataUpdateCoordinator


@pytest.fixture
def mock_hass():
    """Mock Home Assistant."""
    hass = MagicMock()
    hass.async_add_executor_job = AsyncMock()
    hass.bus.async_fire = MagicMock()
    hass.loop.call_soon_threadsafe = MagicMock()
    return hass


@pytest.fixture
def mock_config_entry():
    """Mock config entry."""
    config_entry = MagicMock()
    config_entry.data = {
        CONF_SERIAL_NUMBER: "VS6-EU-HJA1234A",
        CONF_DEVICE_NAME: "Living Room Fan",
    }
    return config_entry


class TestDysonDataUpdateCoordinatorBasics:
    """Test basic coordinator functionality for coverage."""

    @pytest.mark.asyncio
    async def test_serial_number_property(self, mock_hass, mock_config_entry):
        """Test serial number property access."""
        with patch("custom_components.hass_dyson.coordinator.DataUpdateCoordinator.__init__"):
            coordinator = DysonDataUpdateCoordinator(mock_hass, mock_config_entry)
            coordinator.config_entry = mock_config_entry

        assert coordinator.serial_number == "VS6-EU-HJA1234A"

    @pytest.mark.asyncio
    async def test_serial_number_fallback(self, mock_hass):
        """Test serial number fallback behavior."""
        config_entry = MagicMock()
        config_entry.data = {"device_serial_number": "FALLBACK123"}

        with patch("custom_components.hass_dyson.coordinator.DataUpdateCoordinator.__init__"):
            coordinator = DysonDataUpdateCoordinator(mock_hass, config_entry)
            coordinator.config_entry = config_entry

        assert coordinator.serial_number == "FALLBACK123"

    @pytest.mark.asyncio
    async def test_device_name_from_config(self, mock_hass, mock_config_entry):
        """Test device name from config."""
        with patch("custom_components.hass_dyson.coordinator.DataUpdateCoordinator.__init__"):
            coordinator = DysonDataUpdateCoordinator(mock_hass, mock_config_entry)
            coordinator.config_entry = mock_config_entry

        assert coordinator.device_name == "Living Room Fan"

    @pytest.mark.asyncio
    async def test_device_name_fallback(self, mock_hass):
        """Test device name fallback to serial."""
        config_entry = MagicMock()
        config_entry.data = {CONF_SERIAL_NUMBER: "VS6-EU-HJA1234A"}

        with patch("custom_components.hass_dyson.coordinator.DataUpdateCoordinator.__init__"):
            coordinator = DysonDataUpdateCoordinator(mock_hass, config_entry)
            coordinator.config_entry = config_entry

        assert coordinator.device_name == "Dyson VS6-EU-HJA1234A"

    @pytest.mark.asyncio
    async def test_properties_initialization(self, mock_hass, mock_config_entry):
        """Test coordinator properties are initialized."""
        with patch("custom_components.hass_dyson.coordinator.DataUpdateCoordinator.__init__"):
            coordinator = DysonDataUpdateCoordinator(mock_hass, mock_config_entry)

        assert coordinator.device_capabilities == []
        assert coordinator.device_category == []
        assert coordinator.firmware_version == "Unknown"
        assert coordinator.firmware_auto_update_enabled is False

    @pytest.mark.asyncio
    async def test_schedule_listener_update(self, mock_hass, mock_config_entry):
        """Test listener update scheduling."""
        with patch("custom_components.hass_dyson.coordinator.DataUpdateCoordinator.__init__"):
            coordinator = DysonDataUpdateCoordinator(mock_hass, mock_config_entry)
            coordinator.hass = mock_hass
            coordinator.async_update_listeners = MagicMock()

        coordinator._schedule_listener_update()

        mock_hass.loop.call_soon_threadsafe.assert_called_once_with(coordinator.async_update_listeners)

    @pytest.mark.asyncio
    async def test_schedule_fallback_update(self, mock_hass, mock_config_entry):
        """Test fallback update scheduling."""
        with patch("custom_components.hass_dyson.coordinator.DataUpdateCoordinator.__init__"):
            coordinator = DysonDataUpdateCoordinator(mock_hass, mock_config_entry)
            coordinator.hass = mock_hass
            coordinator.async_update_listeners = MagicMock()

        coordinator._schedule_fallback_update()

        mock_hass.loop.call_soon_threadsafe.assert_called_once_with(coordinator.async_update_listeners)

    @pytest.mark.asyncio
    async def test_schedule_fallback_update_exception(self, mock_hass, mock_config_entry):
        """Test fallback update scheduling with exception."""
        mock_hass.loop.call_soon_threadsafe.side_effect = Exception("Scheduler error")

        with patch("custom_components.hass_dyson.coordinator.DataUpdateCoordinator.__init__"):
            coordinator = DysonDataUpdateCoordinator(mock_hass, mock_config_entry)
            coordinator.hass = mock_hass
            coordinator.async_update_listeners = MagicMock()

        # Should not raise exception, just log warning
        coordinator._schedule_fallback_update()

    @pytest.mark.asyncio
    async def test_on_environmental_update(self, mock_hass, mock_config_entry):
        """Test environmental update callback."""
        mock_device = MagicMock()
        mock_device._environmental_data = {"pm25": 10, "pm10": 15}

        with patch("custom_components.hass_dyson.coordinator.DataUpdateCoordinator.__init__"):
            coordinator = DysonDataUpdateCoordinator(mock_hass, mock_config_entry)
            coordinator.hass = mock_hass
            coordinator.device = mock_device
            coordinator.serial_number = "TEST123"
            coordinator.async_update_listeners = MagicMock()

        coordinator._on_environmental_update()

        mock_hass.loop.call_soon_threadsafe.assert_called()

    @pytest.mark.asyncio
    async def test_on_message_update(self, mock_hass, mock_config_entry):
        """Test message update callback."""
        with patch("custom_components.hass_dyson.coordinator.DataUpdateCoordinator.__init__"):
            coordinator = DysonDataUpdateCoordinator(mock_hass, mock_config_entry)
            coordinator.hass = mock_hass
            coordinator._handle_state_change_message = MagicMock()

        coordinator._on_message_update("STATE/CURRENT", {"key": "value"})

        coordinator._handle_state_change_message.assert_called_once()

    @pytest.mark.asyncio
    async def test_handle_state_change_message(self, mock_hass, mock_config_entry):
        """Test state change message handling."""
        with patch("custom_components.hass_dyson.coordinator.DataUpdateCoordinator.__init__"):
            coordinator = DysonDataUpdateCoordinator(mock_hass, mock_config_entry)
            coordinator.hass = mock_hass
            coordinator._schedule_coordinator_data_update = MagicMock()
            coordinator._schedule_listener_update = MagicMock()

        coordinator._handle_state_change_message()

        coordinator._schedule_coordinator_data_update.assert_called_once()
        coordinator._schedule_listener_update.assert_called_once()

    @pytest.mark.asyncio
    async def test_schedule_coordinator_data_update(self, mock_hass, mock_config_entry):
        """Test coordinator data update scheduling."""
        with patch("custom_components.hass_dyson.coordinator.DataUpdateCoordinator.__init__"):
            coordinator = DysonDataUpdateCoordinator(mock_hass, mock_config_entry)
            coordinator.hass = mock_hass
            coordinator._create_coordinator_update_task = MagicMock()

        coordinator._schedule_coordinator_data_update()

        mock_hass.loop.call_soon_threadsafe.assert_called_once_with(coordinator._create_coordinator_update_task)

    @pytest.mark.asyncio
    async def test_create_coordinator_update_task(self, mock_hass, mock_config_entry):
        """Test coordinator update task creation."""
        with patch("custom_components.hass_dyson.coordinator.DataUpdateCoordinator.__init__"):
            coordinator = DysonDataUpdateCoordinator(mock_hass, mock_config_entry)
            coordinator.hass = mock_hass

        mock_hass.async_create_task = MagicMock()

        coordinator._create_coordinator_update_task()

        mock_hass.async_create_task.assert_called_once()

    @pytest.mark.asyncio
    async def test_update_coordinator_data(self, mock_hass, mock_config_entry):
        """Test coordinator data update."""
        with patch("custom_components.hass_dyson.coordinator.DataUpdateCoordinator.__init__"):
            coordinator = DysonDataUpdateCoordinator(mock_hass, mock_config_entry)
            coordinator.async_request_refresh = AsyncMock()

        await coordinator._update_coordinator_data()

        coordinator.async_request_refresh.assert_called_once()

    @pytest.mark.asyncio
    async def test_async_send_command_success(self, mock_hass, mock_config_entry):
        """Test successful command sending."""
        mock_device = AsyncMock()
        mock_device.send_command.return_value = True

        with patch("custom_components.hass_dyson.coordinator.DataUpdateCoordinator.__init__"):
            coordinator = DysonDataUpdateCoordinator(mock_hass, mock_config_entry)
            coordinator.device = mock_device

        result = await coordinator.async_send_command("TEST_CMD", {"key": "value"})

        assert result is True
        mock_device.send_command.assert_called_once_with("TEST_CMD", {"key": "value"})

    @pytest.mark.asyncio
    async def test_async_send_command_no_device(self, mock_hass, mock_config_entry):
        """Test command sending with no device."""
        with patch("custom_components.hass_dyson.coordinator.DataUpdateCoordinator.__init__"):
            coordinator = DysonDataUpdateCoordinator(mock_hass, mock_config_entry)
            coordinator.device = None

        result = await coordinator.async_send_command("TEST_CMD")

        assert result is False

    @pytest.mark.asyncio
    async def test_async_send_command_exception(self, mock_hass, mock_config_entry):
        """Test command sending with exception."""
        mock_device = AsyncMock()
        mock_device.send_command.side_effect = Exception("Connection failed")

        with patch("custom_components.hass_dyson.coordinator.DataUpdateCoordinator.__init__"):
            coordinator = DysonDataUpdateCoordinator(mock_hass, mock_config_entry)
            coordinator.device = mock_device

        result = await coordinator.async_send_command("TEST_CMD")

        assert result is False

    @pytest.mark.asyncio
    async def test_async_set_firmware_auto_update_enable(self, mock_hass, mock_config_entry):
        """Test enabling firmware auto update."""
        mock_device = AsyncMock()
        mock_device.set_firmware_auto_update.return_value = True

        with patch("custom_components.hass_dyson.coordinator.DataUpdateCoordinator.__init__"):
            coordinator = DysonDataUpdateCoordinator(mock_hass, mock_config_entry)
            coordinator.device = mock_device
            coordinator._firmware_auto_update_enabled = False

        result = await coordinator.async_set_firmware_auto_update(True)

        assert result is True
        assert coordinator._firmware_auto_update_enabled is True
        mock_device.set_firmware_auto_update.assert_called_once_with(True)

    @pytest.mark.asyncio
    async def test_async_set_firmware_auto_update_no_device(self, mock_hass, mock_config_entry):
        """Test firmware auto update with no device."""
        with patch("custom_components.hass_dyson.coordinator.DataUpdateCoordinator.__init__"):
            coordinator = DysonDataUpdateCoordinator(mock_hass, mock_config_entry)
            coordinator.device = None

        result = await coordinator.async_set_firmware_auto_update(True)

        assert result is False

    @pytest.mark.asyncio
    async def test_async_shutdown_with_device(self, mock_hass, mock_config_entry):
        """Test shutdown with device present."""
        mock_device = AsyncMock()

        with patch("custom_components.hass_dyson.coordinator.DataUpdateCoordinator.__init__"):
            coordinator = DysonDataUpdateCoordinator(mock_hass, mock_config_entry)
            coordinator.device = mock_device

        await coordinator.async_shutdown()

        mock_device.disconnect.assert_called_once()

    @pytest.mark.asyncio
    async def test_async_shutdown_no_device(self, mock_hass, mock_config_entry):
        """Test shutdown with no device."""
        with patch("custom_components.hass_dyson.coordinator.DataUpdateCoordinator.__init__"):
            coordinator = DysonDataUpdateCoordinator(mock_hass, mock_config_entry)
            coordinator.device = None

        # Should not raise exception
        await coordinator.async_shutdown()

    @pytest.mark.asyncio
    async def test_async_update_data_success(self, mock_hass, mock_config_entry):
        """Test successful data update."""
        mock_device = MagicMock()
        mock_device.get_environmental_data.return_value = {"pm25": 10, "pm10": 15}
        mock_device.get_status.return_value = {"power": "ON", "speed": 5}

        with patch("custom_components.hass_dyson.coordinator.DataUpdateCoordinator.__init__"):
            coordinator = DysonDataUpdateCoordinator(mock_hass, mock_config_entry)
            coordinator.device = mock_device
            coordinator._async_handle_faults = AsyncMock()

        result = await coordinator._async_update_data()

        assert "environmental_data" in result
        assert "status" in result
        assert result["environmental_data"]["pm25"] == 10
        assert result["status"]["power"] == "ON"

    @pytest.mark.asyncio
    async def test_async_update_data_no_device(self, mock_hass, mock_config_entry):
        """Test data update with no device."""
        with patch("custom_components.hass_dyson.coordinator.DataUpdateCoordinator.__init__"):
            coordinator = DysonDataUpdateCoordinator(mock_hass, mock_config_entry)
            coordinator.device = None

        with pytest.raises(UpdateFailed, match="Device not available"):
            await coordinator._async_update_data()

    @pytest.mark.asyncio
    async def test_async_update_data_exception(self, mock_hass, mock_config_entry):
        """Test data update with exception."""
        mock_device = MagicMock()
        mock_device.get_environmental_data.side_effect = Exception("Connection error")

        with patch("custom_components.hass_dyson.coordinator.DataUpdateCoordinator.__init__"):
            coordinator = DysonDataUpdateCoordinator(mock_hass, mock_config_entry)
            coordinator.device = mock_device

        with pytest.raises(UpdateFailed, match="Error communicating with device"):
            await coordinator._async_update_data()

    @pytest.mark.asyncio
    async def test_async_handle_faults_no_faults(self, mock_hass, mock_config_entry):
        """Test fault handling with no faults."""
        mock_device = MagicMock()
        mock_device.get_faults.return_value = []

        with patch("custom_components.hass_dyson.coordinator.DataUpdateCoordinator.__init__"):
            coordinator = DysonDataUpdateCoordinator(mock_hass, mock_config_entry)
            coordinator.device = mock_device
            coordinator.hass = mock_hass

        await coordinator._async_handle_faults()

        # Should not fire any events
        mock_hass.bus.async_fire.assert_not_called()

    @pytest.mark.asyncio
    async def test_async_handle_faults_with_faults(self, mock_hass, mock_config_entry):
        """Test fault handling with faults present."""
        mock_device = MagicMock()
        mock_device.get_faults.return_value = ["fault1", "fault2"]

        with patch("custom_components.hass_dyson.coordinator.DataUpdateCoordinator.__init__"):
            coordinator = DysonDataUpdateCoordinator(mock_hass, mock_config_entry)
            coordinator.device = mock_device
            coordinator.hass = mock_hass
            coordinator.serial_number = "TEST123"

        await coordinator._async_handle_faults()

        # Should fire event for each fault
        assert mock_hass.bus.async_fire.call_count == 2
