# MQTT Device Fixture Architecture

## Overview

This document describes the scalable, device-centric test architecture for the Dyson Home
Assistant integration. It replaces ad-hoc inline mocks with a structured system of
per-device-type MQTT fixtures that are captured from real hardware, sanitized, committed to
the repository, and consumed by a pytest fixture factory.

The primary goals are:

- **Accuracy**: Test data reflects what real devices actually do, including quirks and
  per-product-type variations in the `ec` fan family.
- **Scalability**: Adding a new device type means adding a fixture file, not rewriting tests.
- **Reusability**: A single `DeviceMock` instance can be shared across all tests for a given
  device type via `pytest` fixture parametrization.
- **Maintainability**: Dependent state changes are captured automatically from the real
  device, not hand-coded into the mock.

---

## Constraints

| Constraint | Value |
|---|---|
| Minimum test coverage | 75% |
| All existing tests must pass | Yes |
| All tests must run in devcontainer | Yes |
| All tests must run in CI containers | Yes |
| Device simulator complexity (this phase) | Unit and integration only — no end-to-end |
| State mutation model | State-mutating mock (not pure replay, not full simulator) |

---

## Layered Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│  LAYER 5: Test Files                                                │
│  tests/test_fan.py, tests/test_climate.py, etc.                     │
│  • Consume device_mock fixture without knowing product type          │
│  • Use @pytest.mark.parametrize(device_mock) to matrix over devices │
└────────────────────────────┬────────────────────────────────────────┘
                             │ injects
┌────────────────────────────▼────────────────────────────────────────┐
│  LAYER 4: pytest Fixture Factory                                    │
│  tests/device_mocks/fixture_factory.py                              │
│  • Parametrized over all fixture files for a given device category  │
│  • Instantiates DeviceMock from fixture file                        │
│  • Provides scoped fixtures: ec_device_mock, robot_device_mock, etc │
└────────────────────────────┬────────────────────────────────────────┘
                             │ instantiates
┌────────────────────────────▼────────────────────────────────────────┐
│  LAYER 3: DeviceMock Class                                          │
│  tests/device_mocks/device_mock.py                                  │
│  • Loads DeviceFixture (layer 2)                                    │
│  • Maintains current mutable state dict                             │
│  • Handles STATE-SET commands: applies full response delta          │
│  • Returns no_response / rejected sentinel for unsupported commands │
│  • Does NOT simulate device logic — only replays captured deltas    │
└────────────────────────────┬────────────────────────────────────────┘
                             │ loads
┌────────────────────────────▼────────────────────────────────────────┐
│  LAYER 2: DeviceFixture (data class)                                │
│  tests/device_mocks/device_fixture.py                               │
│  • Python dataclass wrapping a loaded fixture JSON file             │
│  • Typed access to initial_state, command_responses, metadata       │
│  • Validates schema version on load                                 │
└────────────────────────────┬────────────────────────────────────────┘
                             │ reads
┌────────────────────────────▼────────────────────────────────────────┐
│  LAYER 1: Fixture JSON Files                                        │
│  tests/fixtures/devices/{category}/{product_type}.json              │
│  • One file per product type (e.g. 438.json, 527.json)             │
│  • Sanitized: no real serial numbers, passwords, or IPs            │
│  • Committed to the repository                                      │
│  • Generated by: HA Capture Service (Layer 0)                      │
└────────────────────────────┬────────────────────────────────────────┘
                             │ generated by
┌────────────────────────────▼────────────────────────────────────────┐
│  LAYER 0: HA Capture Service                                        │
│  custom_components/hass_dyson/services.yaml (capture action)        │
│  • One-time developer/user tool                                     │
│  • Saves current state, sends each known command, records response  │
│  • Restores original device state on completion                     │
│  • Writes sanitized JSON to /config/dyson_fixtures/                 │
└─────────────────────────────────────────────────────────────────────┘
```

---

## File Layout

```
tests/
├── conftest.py                          # existing — gains device_mock fixture imports
├── fixtures/
│   ├── mock_device_api.json             # existing — REST API fixtures (unchanged)
│   ├── mock_device_api_with_update.json # existing — REST API fixtures (unchanged)
│   └── devices/
│       ├── ec/
│       │   ├── 438.json                 # Pure Cool (desk fan)
│       │   ├── 438M.json                # Pure Cool variant
│       │   ├── 475.json                 # Pure Hot+Cool
│       │   ├── 527.json                 # Pure Humidify+Cool
│       │   ├── 527E.json                # Pure Humidify+Cool Formaldehyde
│       │   └── ...                      # one file per product type
│       ├── robot/
│       │   ├── N223.json                # 360 Eye
│       │   ├── 276.json                 # 360 Heurist
│       │   └── ...
│       └── vacuum/
│           └── ...
└── device_mocks/
    ├── __init__.py
    ├── device_fixture.py                # DeviceFixture dataclass
    ├── device_mock.py                   # DeviceMock class
    ├── fixture_factory.py               # pytest fixture factories
    └── sanitizer.py                     # sanitization utilities (used by capture service)
```

---

## Data Flow: Capture → Commit → Test

```
Real Device
    │
    │  MQTT STATUS messages
    ▼
HA Capture Service
    │
    │  writes raw fixture
    ▼
/config/dyson_fixtures/{product_type}.json   (on HA host, NOT committed)
    │
    │  developer downloads, runs sanitizer
    ▼
tests/fixtures/devices/{category}/{product_type}.json   (committed)
    │
    │  pytest loads via DeviceFixture
    ▼
DeviceMock (stateful, command-aware)
    │
    │  injected via pytest parametrize
    ▼
Test functions
```

---

## Device Categories and Scope

| Category Constant | Value | Fixture Dir | Command Strategy |
|---|---|---|---|
| `DEVICE_CATEGORY_EC` | `ec` | `tests/fixtures/devices/ec/` | Full ec command universe + probe |
| `DEVICE_CATEGORY_ROBOT` | `robot` | `tests/fixtures/devices/robot/` | Robot-specific command set |
| `DEVICE_CATEGORY_VACUUM` | `vacuum` | `tests/fixtures/devices/vacuum/` | Vacuum-specific command set |
| `DEVICE_CATEGORY_FLRC` | `flrc` | `tests/fixtures/devices/flrc/` | FLRC-specific command set |

`ec` devices receive the **widest command probing** because the product family has the most
per-device variation. The capture service for `ec` devices sends every state key known to the
integration and records what the device does with each one. See
[testing-mqtt-capture-service.md](testing-mqtt-capture-service.md) for details.

---

## State Mutation Model

The `DeviceMock` is a **state-mutating mock**, not a pure replay fixture and not a full
simulator. The distinction matters:

| Model | Description | Used When |
|---|---|---|
| Pure replay | Returns the same response regardless of what commands are sent | Not sufficient — tests assert on state changes |
| **State-mutating mock** | Commands update the mock's state dict using captured response deltas | **This phase** |
| Full simulator | Device logic is re-implemented (dependencies, constraints, error conditions) | Future phase |

For the state-mutating mock:

1. The mock is initialised with `initial_state` from the fixture file.
2. When a `STATE-SET` command is sent, the mock looks up the `command_responses` entry for
   that command.
3. The full response delta (as captured from the real device) is merged into the current
   state dict.
4. Dependent state changes are included automatically because the captured delta already
   contains every field the real device changed.

Example: Sending `STATE-SET {"fnsp": "AUTO"}` on a Pure Cool might cause the device to also
set `fmod=AUTO` and `auto=ON`. The fixture captures all three fields in the response delta.
The mock applies all three. Tests that assert on `auto` will pass without any hand-coded
dependency knowledge.

---

## Relationship to Existing Tests

This architecture is **additive**. Existing tests continue to work unchanged. New tests
written against the `DeviceMock` pattern will co-exist with existing inline mock tests.
Over time, existing tests can be migrated to the new pattern to reduce duplication, but this
is not required and is tracked separately in
[testing-mqtt-migration.md](testing-mqtt-migration.md).

---

## Related Documents

| Document | Purpose |
|---|---|
| [testing-mqtt-fixture-schema.md](testing-mqtt-fixture-schema.md) | JSON schema for fixture files |
| [testing-mqtt-capture-service.md](testing-mqtt-capture-service.md) | HA Action capture service spec |
| [testing-mqtt-device-mock.md](testing-mqtt-device-mock.md) | DeviceMock and DeviceFixture class specs |
| [testing-mqtt-pytest-factory.md](testing-mqtt-pytest-factory.md) | pytest fixture factory and parametrization |
| [testing-mqtt-migration.md](testing-mqtt-migration.md) | Migration path from existing inline mocks |
| [testing-patterns.md](testing-patterns.md) | Existing HA mock patterns (unchanged) |
