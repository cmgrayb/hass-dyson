# MQTT Device Fixture JSON Schema

## Overview

This document specifies the exact JSON schema for device fixture files stored in
`tests/fixtures/devices/{category}/{product_type}.json`. These files are generated by the
HA Capture Service, sanitized, and committed to the repository. They are the canonical
source of truth for what each device type actually does over MQTT.

See [testing-mqtt-fixture-architecture.md](testing-mqtt-fixture-architecture.md) for the
broader context.

---

## Schema Version

The schema is versioned to allow future evolution without breaking existing fixtures. The
current version is **`1`**.

- The `DeviceFixture` loader **must** validate the `schema_version` field on load.
- If the version is unsupported, it must raise a `UnsupportedFixtureVersionError`.
- Version increments are backwards-incompatible; a migration script must accompany any bump.

---

## Top-Level Structure

```json
{
  "schema_version": 1,
  "metadata": { ... },
  "initial_state": { ... },
  "environmental_state": { ... },
  "command_responses": { ... },
  "fault_codes": [ ... ]
}
```

### `schema_version`

| Field | Type | Required | Description |
|---|---|---|---|
| `schema_version` | `integer` | Yes | Schema version. Currently `1`. |

---

### `metadata`

Descriptive information about the device this fixture was captured from.

```json
"metadata": {
  "product_type": "438",
  "mqtt_root_topic_level": "438M",
  "device_category": "ec",
  "device_name": "Test Dyson Device",
  "serial_number": "TEST-438-0001A",
  "firmware_version": "21.01.08",
  "capabilities": [
    "AdvanceOscillationDay1",
    "Scheduling",
    "EnvironmentalData",
    "ExtendedAQ",
    "ChangeWifi"
  ],
  "capture_date": "2026-01-15",
  "capture_tool_version": "1.0.0",
  "notes": "Optional free-text field for quirk documentation."
}
```

| Field | Type | Required | Description |
|---|---|---|---|
| `product_type` | `string` | Yes | Dyson product type code (e.g. `"438"`, `"527"`) |
| `mqtt_root_topic_level` | `string` | Yes | MQTT topic prefix (e.g. `"438M"`) |
| `device_category` | `string` | Yes | One of `ec`, `robot`, `vacuum`, `flrc` |
| `device_name` | `string` | Yes | Sanitized device name |
| `serial_number` | `string` | Yes | Sanitized serial number (see Sanitization Rules) |
| `firmware_version` | `string` | Yes | Firmware at time of capture |
| `capabilities` | `array[string]` | Yes | List of capability strings as reported by the cloud API |
| `capture_date` | `string` | Yes | ISO 8601 date (`YYYY-MM-DD`) |
| `capture_tool_version` | `string` | Yes | Version of the capture service that generated this file |
| `notes` | `string` | No | Free-text field for documenting device-specific quirks |

---

### `initial_state`

The full device state payload as received from a `CURRENT-STATE` MQTT message immediately
before the capture sequence began. This is the state the `DeviceMock` is initialised with.

```json
"initial_state": {
  "fpwr": "ON",
  "fnst": "FAN",
  "fnsp": "0003",
  "oson": "OFF",
  "nmod": "OFF",
  "rhtm": "OFF",
  "auto": "OFF",
  "fdir": "ON",
  "hflr": "100",
  "cflr": "100",
  "sltm": "OFF",
  "ancp": "0315",
  "osau": "0350",
  "osal": "0279"
}
```

- Key names are the raw Dyson MQTT state keys (as defined in `const.py`).
- Values are raw strings as received from the device.
- The full payload is stored, not a filtered subset.
- Missing keys mean the device did not include that field in its `CURRENT-STATE` response —
  this is valid and meaningful (see DeviceMock handling in
  [testing-mqtt-device-mock.md](testing-mqtt-device-mock.md)).

---

### `environmental_state`

The device's environmental sensor state as received from a
`ENVIRONMENTAL-CURRENT-SENSOR-DATA` MQTT message during the capture sequence. May be
`null` if the device does not support environmental data (i.e. lacks the
`EnvironmentalData` capability).

```json
"environmental_state": {
  "tact": "2982",
  "hact": "0052",
  "p25r": "0003",
  "p10r": "0004",
  "va10": "0012",
  "noxl": "0008",
  "pm25": "0003",
  "pm10": "0004",
  "pact": "0003"
}
```

---

### `command_responses`

The full set of commands sent during the capture sequence, and how the device responded to
each one. This is the most important section — it is the source of truth for what each
device does when commanded.

```json
"command_responses": {
  "STATE-SET": {
    "fpwr=OFF": {
      "status": "responded",
      "delta": {
        "fpwr": "OFF",
        "fnst": "OFF"
      }
    },
    "fnsp=0005": {
      "status": "responded",
      "delta": {
        "fnsp": "0005",
        "fmod": "FAN",
        "auto": "OFF"
      }
    },
    "fnsp=AUTO": {
      "status": "responded",
      "delta": {
        "fnsp": "AUTO",
        "fmod": "AUTO",
        "auto": "ON"
      }
    },
    "ancp=BRZE": {
      "status": "no_response"
    },
    "hmod=HEAT": {
      "status": "rejected",
      "response": {
        "msg": "STATE-CHANGE",
        "product-state": {
          "err": "INVALID_PARAM"
        }
      }
    }
  }
}
```

#### Structure

The top level of `command_responses` is keyed by MQTT command type. For `ec` and `robot`
devices this is typically `"STATE-SET"`. Separate command types (e.g. robot start/stop
commands) have their own top-level key.

Within each command type, entries are keyed by a **command key** string in the format
`"{state_key}={value}"` for single-field `STATE-SET` commands, or by a descriptive string
for multi-field commands.

> **Read-only state fields must never appear as command keys.** Some Dyson state keys are
> device-reported status fields that cannot be sent as commands. For example, `hsta`
> (Heating Status) is reported by the device as a side-effect of sending `hmod=HEAT` — it
> may appear in a response `delta` but must never be used as a command key. When reviewing
> a captured fixture, any command key that produces only `no_response` across all devices
> should be investigated as a possible read-only field.

#### Response Entry Schema

Each entry is an object with a `status` field and optional additional fields:

| `status` value | Meaning | Additional fields |
|---|---|---|
| `"responded"` | Device sent a `STATE-CHANGE` in response | `delta` (required): object containing all state fields the device changed |
| `"no_response"` | Device sent nothing within the capture timeout | None |
| `"rejected"` | Device sent an explicit error response | `response` (required): the raw error payload from the device |

#### Why Three Statuses Matter

- **`responded`**: The mock applies the `delta` to its state dict. This handles dependent
  state changes automatically.
- **`no_response`**: The mock ignores the command silently. Tests can assert that state did
  not change.
- **`rejected`**: The mock does not change state and can optionally surface the error
  payload. Tests can assert on rejection behavior.

---

### `fault_codes`

A list of known fault codes that this device can produce, as observed during the capture
sequence or documented from other sources. May be empty if no faults were observed.

```json
"fault_codes": [
  {
    "code": "mflr",
    "description": "Motor/fan fault",
    "sample_payload": {
      "msg": "CURRENT-FAULTS",
      "faults": {
        "mflr": { "active": true, "description": "Motor fault detected" }
      }
    }
  }
]
```

| Field | Type | Required | Description |
|---|---|---|---|
| `code` | `string` | Yes | Fault code key |
| `description` | `string` | Yes | Human-readable description |
| `sample_payload` | `object` | No | Raw MQTT fault payload as observed |

---

## Sanitization Rules

All fixture files committed to the repository must be sanitized. The following substitutions
are applied by the capture service before writing the file, and validated by the
`DeviceFixture` loader (it rejects files containing real-looking values).

| Field | Real Value Pattern | Sanitized Value |
|---|---|---|
| `metadata.serial_number` | e.g. `VS6-EU-HJA1234A` | `TEST-{product_type}-0001A` |
| `metadata.device_name` | User-assigned name | `Test Dyson Device` |
| MQTT password (if present) | Any credential string | `test-mqtt-password-sanitized` |
| Device IP (if present) | Any IPv4 address | `192.168.1.100` |
| WiFi SSID (if present) | Network name | `TestNetwork` |
| WiFi password (if present) | Network password | `test-wifi-password-sanitized` |

### Validation on Load

The `DeviceFixture` loader applies these checks to reject accidentally unsanitized files:

- `metadata.serial_number` must match the pattern `TEST-[A-Z0-9]+-[0-9]+[A-Z]`
- `metadata.device_name` must not contain spaces followed by capital letters typical of
  real user-assigned names (heuristic — relaxed if it causes false positives)
- No field anywhere in the document may contain a string matching the pattern
  `[A-Z][A-Z0-9]{1,3}-[A-Z]{2}-[A-Z]{3}[0-9]{4}[A-Z]` (real Dyson serial format)

---

## Complete Example: `438.json` (Pure Cool Desk Fan)

```json
{
  "schema_version": 1,
  "metadata": {
    "product_type": "438",
    "mqtt_root_topic_level": "438M",
    "device_category": "ec",
    "device_name": "Test Dyson Device",
    "serial_number": "TEST-438-0001A",
    "firmware_version": "21.01.08",
    "capabilities": [
      "AdvanceOscillationDay1",
      "Scheduling",
      "EnvironmentalData",
      "ExtendedAQ",
      "ChangeWifi"
    ],
    "capture_date": "2026-01-15",
    "capture_tool_version": "1.0.0",
    "notes": "Standard Pure Cool desk fan. Supports advanced oscillation."
  },
  "initial_state": {
    "fpwr": "ON",
    "fnst": "FAN",
    "fnsp": "0003",
    "oson": "OFF",
    "nmod": "OFF",
    "rhtm": "OFF",
    "auto": "OFF",
    "fdir": "ON",
    "hflr": "100",
    "cflr": "100",
    "sltm": "OFF",
    "ancp": "0315",
    "osau": "0350",
    "osal": "0279"
  },
  "environmental_state": {
    "tact": "2982",
    "hact": "0052",
    "p25r": "0003",
    "p10r": "0004",
    "va10": "0012",
    "noxl": "0008"
  },
  "command_responses": {
    "STATE-SET": {
      "fpwr=OFF": {
        "status": "responded",
        "delta": { "fpwr": "OFF", "fnst": "OFF" }
      },
      "fpwr=ON": {
        "status": "responded",
        "delta": { "fpwr": "ON", "fnst": "FAN" }
      },
      "fnsp=0001": {
        "status": "responded",
        "delta": { "fnsp": "0001" }
      },
      "fnsp=0010": {
        "status": "responded",
        "delta": { "fnsp": "0010" }
      },
      "fnsp=AUTO": {
        "status": "responded",
        "delta": { "fnsp": "AUTO", "fmod": "AUTO", "auto": "ON" }
      },
      "nmod=ON": {
        "status": "responded",
        "delta": { "nmod": "ON" }
      },
      "nmod=OFF": {
        "status": "responded",
        "delta": { "nmod": "OFF" }
      },
      "oson=ON": {
        "status": "responded",
        "delta": { "oson": "ON" }
      },
      "oson=OFF": {
        "status": "responded",
        "delta": { "oson": "OFF" }
      },
      "ancp=BRZE": {
        "status": "no_response"
      },
      "rhtm=ON": {
        "status": "responded",
        "delta": { "rhtm": "ON" }
      },
      "sltm=0030": {
        "status": "responded",
        "delta": { "sltm": "0030" }
      },
      "hume=HUMD": {
        "status": "rejected",
        "response": { "err": "INVALID_PARAM" }
      }
    }
  },
  "fault_codes": []
}
```

---

## Naming Conventions

| Convention | Rule |
|---|---|
| Filename | `{product_type}.json` where product type matches the Dyson API `type` field |
| Variant suffix | If a variant exists (e.g. `438M`), the file is `438M.json` |
| Directory | `tests/fixtures/devices/{device_category}/` |
| Multiple fixtures for same product type | Not supported — one file per product type |

---

## Versioning and Maintenance

### When a firmware update changes device behavior

1. Re-run the capture service against the updated device.
2. Diff the new fixture file against the committed version.
3. If the delta is meaningful, update the fixture file and note the firmware version change
   in `metadata.firmware_version` and `metadata.notes`.
4. Re-run all tests. If tests fail because the real device now behaves differently, update
   the tests to match the new behavior.

### When a new product type is added to the integration

1. A developer or willing user runs the capture service against their device.
2. The resulting fixture file is committed to `tests/fixtures/devices/{category}/`.
3. The pytest fixture factory automatically discovers and parametrizes over the new file —
   no test code changes are required.

### When the schema is evolved

1. Increment `schema_version`.
2. Write a migration script in `tests/device_mocks/migrations/v{old}_to_v{new}.py`.
3. Update `DeviceFixture.load()` to call the migration script if the loaded version is old.
4. Document the schema change in this document.
